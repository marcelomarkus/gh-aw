// ================================================================
// gh-aw Playground - Application Logic
// ================================================================

import { EditorView, basicSetup } from 'https://esm.sh/codemirror@6.0.2';
import { EditorState, Compartment } from 'https://esm.sh/@codemirror/state@6.5.4';
import { keymap } from 'https://esm.sh/@codemirror/view@6.39.14';
import { yaml } from 'https://esm.sh/@codemirror/lang-yaml@6.1.2';
import { markdown } from 'https://esm.sh/@codemirror/lang-markdown@6.5.0';
import { indentUnit } from 'https://esm.sh/@codemirror/language@6.12.1';
import { oneDark } from 'https://esm.sh/@codemirror/theme-one-dark@6.1.3';
import { createWorkerCompiler } from '/gh-aw/wasm/compiler-loader.js';

// ---------------------------------------------------------------
// Sample workflow templates
// ---------------------------------------------------------------
const SAMPLES = {
  'hello-world': `---
name: hello-world
description: A simple hello world workflow
on:
  workflow_dispatch:
engine: copilot
---

# Mission

Say hello to the world! Check the current date and time, and greet the user warmly.
`,

  'issue-triage': `---
description: |
  Intelligent issue triage assistant that processes new and reopened issues.
  Analyzes issue content, selects appropriate labels, detects spam, gathers context
  from similar issues, and provides analysis notes including debugging strategies,
  reproduction steps, and resource links.

on:
  issues:
    types: [opened, reopened]
  reaction: eyes

permissions: read-all

network: defaults

safe-outputs:
  add-labels:
    max: 5
  add-comment:

tools:
  web-fetch:
  github:
    toolsets: [issues]
    lockdown: false

timeout-minutes: 10
---

# Agentic Triage

You're a triage assistant for GitHub issues. Your task is to analyze issue #\${{ github.event.issue.number }} and perform some initial triage tasks related to that issue.

1. Select appropriate labels for the issue from the provided list.

2. Retrieve the issue content using the \`get_issue\` tool. If the issue is obviously spam, or generated by bot, or something else that is not an actual issue to be worked on, then add an issue comment to the issue with a one-sentence analysis and exit the workflow.

3. Next, use the GitHub tools to gather additional context about the issue:

   - Fetch the list of labels available in this repository. Use 'gh label list' bash command to fetch the labels.
   - Fetch any comments on the issue using the \`get_issue_comments\` tool
   - Find similar issues if needed using the \`search_issues\` tool
   - List the issues to see other open issues in the repository using the \`list_issues\` tool

4. Analyze the issue content, considering:

   - The issue title and description
   - The type of issue (bug report, feature request, question, etc.)
   - Technical areas mentioned
   - Severity or priority indicators
   - User impact
   - Components affected

5. Write notes, ideas, nudges, resource links, debugging strategies and/or reproduction steps for the team to consider relevant to the issue.

6. Select appropriate labels from the available labels list:

   - Choose labels that accurately reflect the issue's nature
   - Be specific but comprehensive
   - Select priority labels if you can determine urgency
   - Only select labels from the provided list above

7. Apply the selected labels using the \`update_issue\` tool.

8. Add an issue comment with your analysis:
   - Start with "Agentic Issue Triage"
   - Provide a brief summary of the issue
   - Include any debugging strategies or reproduction steps if applicable
   - Suggest resources or links that might be helpful
   - Use collapsed-by-default sections in the GitHub markdown to keep the comment tidy.
`,

  'ci-doctor': `---
description: |
  Automated CI failure investigator that triggers when monitored workflows fail.
  Performs deep analysis of GitHub Actions workflow failures to identify root causes,
  patterns, and provide actionable remediation steps.

on:
  workflow_run:
    workflows: ["CI"]
    types:
      - completed
    branches:
      - main

if: \${{ github.event.workflow_run.conclusion == 'failure' }}

permissions: read-all

network: defaults

safe-outputs:
  create-issue:
    title-prefix: "\${{ github.workflow }}"
    labels: [automation, ci]
  add-comment:

tools:
  cache-memory: true
  web-fetch:

timeout-minutes: 10
---

# CI Failure Doctor

You are the CI Failure Doctor, an expert investigative agent that analyzes failed GitHub Actions workflows to identify root causes and patterns.

## Current Context

- **Repository**: \${{ github.repository }}
- **Workflow Run**: \${{ github.event.workflow_run.id }}
- **Conclusion**: \${{ github.event.workflow_run.conclusion }}
- **Run URL**: \${{ github.event.workflow_run.html_url }}
- **Head SHA**: \${{ github.event.workflow_run.head_sha }}

## Investigation Protocol

**ONLY proceed if the workflow conclusion is 'failure' or 'cancelled'**. Exit immediately if the workflow was successful.

### Phase 1: Initial Triage

1. **Verify Failure**: Check that \${{ github.event.workflow_run.conclusion }} is failure or cancelled
2. **Get Workflow Details**: Use \`get_workflow_run\` to get full details of the failed run
3. **List Jobs**: Use \`list_workflow_jobs\` to identify which specific jobs failed
4. **Quick Assessment**: Determine if this is a new type of failure or a recurring pattern

### Phase 2: Deep Log Analysis

1. **Retrieve Logs**: Use \`get_job_logs\` with \`failed_only=true\` to get logs from all failed jobs
2. **Pattern Recognition**: Analyze logs for error messages, stack traces, dependency failures, infrastructure issues, timeout patterns, and resource constraints
3. **Extract Key Information**: Primary error messages, file paths and line numbers, test names, dependency versions, timing patterns

### Phase 3: Root Cause Investigation

1. **Categorize Failure Type**:
   - Code Issues, Infrastructure, Dependencies, Configuration, Flaky Tests, External Services

2. **Deep Dive Analysis**:
   - For test failures: Identify specific test methods and assertions
   - For build failures: Analyze compilation errors and missing dependencies
   - For infrastructure issues: Check runner logs and resource usage

### Phase 4: Reporting

1. **Create Investigation Report** as a GitHub issue including:
   - Executive Summary
   - Root Cause analysis
   - Reproduction Steps
   - Recommended Actions
   - Prevention Strategies
`,

  'contribution-check': `---
description: |
  Reviews incoming pull requests to verify they comply with the repository's
  contribution guidelines. Checks CONTRIBUTING.md and similar docs, then either
  labels the PR as ready or provides constructive feedback on what needs to be
  improved to meet the guidelines.

on:
  pull_request:
    types: [opened, edited, synchronize]
  reaction: eyes

permissions: read-all

network: defaults

safe-outputs:
  add-labels:
    allowed: [contribution-ready]
    max: 1
  add-comment:
    max: 1

tools:
  github:
    toolsets: [default]
    lockdown: false

timeout-minutes: 10
---

# Contribution Guidelines Checker

You are a contribution guidelines reviewer for GitHub pull requests. Your task is to analyze PR #\${{ github.event.pull_request.number }} and verify it meets the repository's contribution guidelines.

## Step 1: Find Contribution Guidelines

Search for contribution guidelines in the repository. Check these locations in order:

1. \`CONTRIBUTING.md\` in the root directory
2. \`.github/CONTRIBUTING.md\`
3. \`docs/CONTRIBUTING.md\` or \`docs/contributing.md\`
4. Contribution sections in \`README.md\`
5. Other repo-specific docs like \`DEVELOPMENT.md\`, \`HACKING.md\`

Use the GitHub tools to read these files. If no contribution guidelines exist, use general best practices.

## Step 2: Retrieve PR Details

Use the \`get_pull_request\` tool to fetch the full PR details including:
- Title and description
- Changed files list
- Commit messages

## Step 3: Evaluate Compliance

Check the PR against the contribution guidelines for:

- **PR Title**: Does it follow the required format? Is it clear and descriptive?
- **PR Description**: Is it complete? Does it explain the what and why?
- **Commit Messages**: Do they follow the required format (if specified)?
- **Required Sections**: Are all required sections present (e.g., test plan, changelog)?
- **Documentation**: Are docs updated if required by guidelines?

## Step 4: Take Action

**If the PR meets all contribution guidelines:**
- Add the \`contribution-ready\` label to the PR
- Optionally add a brief welcoming comment acknowledging compliance

**If the PR needs improvements:**
- Add a helpful comment that includes:
  - A friendly greeting (be welcoming, especially to first-time contributors)
  - Specific guidelines that are not being met
  - Clear, actionable steps to bring the PR into compliance
  - Links to relevant sections of the contribution guidelines
- Do NOT add the \`contribution-ready\` label
`,

  'daily-repo-status': `---
description: |
  Creates daily repo status reports. Gathers recent repository activity
  (issues, PRs, discussions, releases, code changes) and generates engaging
  GitHub issues with productivity insights, community highlights, and
  project recommendations.

on:
  schedule: daily
  workflow_dispatch:

permissions:
  contents: read
  issues: read
  pull-requests: read

network: defaults

tools:
  github:
    lockdown: false

safe-outputs:
  create-issue:
    title-prefix: "[repo-status] "
    labels: [report, daily-status]
---

# Daily Repo Status

Create an upbeat daily status report for the repo as a GitHub issue.

## What to include

- Recent repository activity (issues, PRs, discussions, releases, code changes)
- Progress tracking, goal reminders and highlights
- Project status and recommendations
- Actionable next steps for maintainers

## Style

- Be positive, encouraging, and helpful
- Use emojis moderately for engagement
- Keep it concise - adjust length based on actual activity

## Process

1. Gather recent activity from the repository
2. Study the repository, its issues and its pull requests
3. Create a new GitHub issue with your findings and insights
`,
};

const DEFAULT_CONTENT = SAMPLES['hello-world'];

// ---------------------------------------------------------------
// DOM Elements
// ---------------------------------------------------------------
const $ = (id) => document.getElementById(id);

const sampleSelect = $('sampleSelect');
const editorMount = $('editorMount');
const outputPlaceholder = $('outputPlaceholder');
const outputMount = $('outputMount');
const outputContainer = $('outputContainer');
const statusBadge = $('statusBadge');
const statusText = $('statusText');
const statusDot = $('statusDot');
const loadingOverlay = $('loadingOverlay');
const errorBanner = $('errorBanner');
const errorText = $('errorText');
const warningBanner = $('warningBanner');
const warningText = $('warningText');
const themeToggle = $('themeToggle');
const divider = $('divider');
const panelEditor = $('panelEditor');
const panelOutput = $('panelOutput');
const panels = $('panels');

// ---------------------------------------------------------------
// State
// ---------------------------------------------------------------
let compiler = null;
let isReady = false;
let isCompiling = false;
let compileTimer = null;
let currentYaml = '';

// ---------------------------------------------------------------
// Theme (uses Primer's data-color-mode)
// ---------------------------------------------------------------
const editorThemeConfig = new Compartment();
const outputThemeConfig = new Compartment();

function getPreferredTheme() {
  const saved = localStorage.getItem('gh-aw-playground-theme');
  if (saved) return saved;
  return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
}

function cmThemeFor(theme) {
  return theme === 'dark' ? oneDark : [];
}

function setTheme(theme) {
  document.documentElement.setAttribute('data-color-mode', theme);
  localStorage.setItem('gh-aw-playground-theme', theme);
  const sunIcon = themeToggle.querySelector('.icon-sun');
  const moonIcon = themeToggle.querySelector('.icon-moon');
  if (theme === 'dark') {
    sunIcon.style.display = 'block';
    moonIcon.style.display = 'none';
  } else {
    sunIcon.style.display = 'none';
    moonIcon.style.display = 'block';
  }

  // Update CodeMirror themes
  const cmTheme = cmThemeFor(theme);
  editorView.dispatch({ effects: editorThemeConfig.reconfigure(cmTheme) });
  outputView.dispatch({ effects: outputThemeConfig.reconfigure(cmTheme) });
}

// ---------------------------------------------------------------
// CodeMirror: Input Editor (Markdown with YAML frontmatter)
// ---------------------------------------------------------------
const editorView = new EditorView({
  doc: DEFAULT_CONTENT,
  extensions: [
    basicSetup,
    markdown(),
    EditorState.tabSize.of(2),
    indentUnit.of('  '),
    editorThemeConfig.of(cmThemeFor(getPreferredTheme())),
    keymap.of([{
      key: 'Mod-Enter',
      run: () => { doCompile(); return true; }
    }]),
    EditorView.updateListener.of(update => {
      if (update.docChanged && isReady) {
        scheduleCompile();
      }
    }),
  ],
  parent: editorMount,
});

// ---------------------------------------------------------------
// CodeMirror: Output View (YAML, read-only)
// ---------------------------------------------------------------
const outputView = new EditorView({
  doc: '',
  extensions: [
    basicSetup,
    yaml(),
    EditorState.readOnly.of(true),
    EditorView.editable.of(false),
    outputThemeConfig.of(cmThemeFor(getPreferredTheme())),
  ],
  parent: outputMount,
});

// ---------------------------------------------------------------
// Apply initial theme + listen for changes
// ---------------------------------------------------------------
setTheme(getPreferredTheme());

themeToggle.addEventListener('click', () => {
  const current = document.documentElement.getAttribute('data-color-mode');
  setTheme(current === 'dark' ? 'light' : 'dark');
});

// Listen for OS theme changes
window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
  if (!localStorage.getItem('gh-aw-playground-theme')) {
    setTheme(e.matches ? 'dark' : 'light');
  }
});

// ---------------------------------------------------------------
// Sample selector
// ---------------------------------------------------------------
sampleSelect.addEventListener('change', () => {
  const content = SAMPLES[sampleSelect.value];
  if (!content) return;
  editorView.dispatch({
    changes: { from: 0, to: editorView.state.doc.length, insert: content }
  });
});

// ---------------------------------------------------------------
// Status (uses Primer Label component)
// ---------------------------------------------------------------
const STATUS_LABEL_MAP = {
  loading: 'Label--accent',
  ready: 'Label--success',
  compiling: 'Label--accent',
  error: 'Label--danger'
};

function setStatus(status, text) {
  // Swap Label modifier class
  Object.values(STATUS_LABEL_MAP).forEach(cls => statusBadge.classList.remove(cls));
  statusBadge.classList.add(STATUS_LABEL_MAP[status] || 'Label--secondary');
  statusBadge.setAttribute('data-status', status);
  statusText.textContent = text;

  // Pulse animation for loading/compiling states
  if (status === 'loading' || status === 'compiling') {
    statusDot.style.animation = 'pulse 1.2s ease-in-out infinite';
  } else {
    statusDot.style.animation = '';
  }
}

// ---------------------------------------------------------------
// Compile
// ---------------------------------------------------------------
function scheduleCompile() {
  if (compileTimer) clearTimeout(compileTimer);
  compileTimer = setTimeout(doCompile, 400);
}

async function doCompile() {
  if (!isReady || isCompiling) return;
  if (compileTimer) {
    clearTimeout(compileTimer);
    compileTimer = null;
  }

  const md = editorView.state.doc.toString();
  if (!md.trim()) {
    outputMount.style.display = 'none';
    outputPlaceholder.classList.remove('d-none');
    outputPlaceholder.classList.add('d-flex');
    outputPlaceholder.textContent = 'Compiled YAML will appear here';
    currentYaml = '';
    return;
  }

  isCompiling = true;
  setStatus('compiling', 'Compiling...');

  // Hide old banners
  errorBanner.classList.add('d-none');
  warningBanner.classList.add('d-none');

  try {
    const result = await compiler.compile(md);

    if (result.error) {
      setStatus('error', 'Error');
      errorText.textContent = result.error;
      errorBanner.classList.remove('d-none');
    } else {
      setStatus('ready', 'Ready');
      currentYaml = result.yaml;

      // Update output CodeMirror view
      outputView.dispatch({
        changes: { from: 0, to: outputView.state.doc.length, insert: result.yaml }
      });
      outputMount.style.display = 'block';
      outputPlaceholder.classList.add('d-none');
      outputPlaceholder.classList.remove('d-flex');

      if (result.warnings && result.warnings.length > 0) {
        warningText.textContent = result.warnings.join('\n');
        warningBanner.classList.remove('d-none');
      }
    }
  } catch (err) {
    setStatus('error', 'Error');
    errorText.textContent = err.message || String(err);
    errorBanner.classList.remove('d-none');
  } finally {
    isCompiling = false;
  }
}

// ---------------------------------------------------------------
// Banner close
// ---------------------------------------------------------------
$('errorClose').addEventListener('click', () => errorBanner.classList.add('d-none'));
$('warningClose').addEventListener('click', () => warningBanner.classList.add('d-none'));

// ---------------------------------------------------------------
// Draggable divider
// ---------------------------------------------------------------
let isDragging = false;

divider.addEventListener('mousedown', (e) => {
  isDragging = true;
  divider.classList.add('dragging');
  document.body.style.cursor = 'col-resize';
  document.body.style.userSelect = 'none';
  e.preventDefault();
});

document.addEventListener('mousemove', (e) => {
  if (!isDragging) return;
  const rect = panels.getBoundingClientRect();
  const isMobile = window.innerWidth < 768;

  if (isMobile) {
    const fraction = (e.clientY - rect.top) / rect.height;
    const clamped = Math.max(0.2, Math.min(0.8, fraction));
    panelEditor.style.flex = `0 0 ${clamped * 100}%`;
    panelOutput.style.flex = `0 0 ${(1 - clamped) * 100}%`;
  } else {
    const fraction = (e.clientX - rect.left) / rect.width;
    const clamped = Math.max(0.2, Math.min(0.8, fraction));
    panelEditor.style.flex = `0 0 ${clamped * 100}%`;
    panelOutput.style.flex = `0 0 ${(1 - clamped) * 100}%`;
  }
});

document.addEventListener('mouseup', () => {
  if (isDragging) {
    isDragging = false;
    divider.classList.remove('dragging');
    document.body.style.cursor = '';
    document.body.style.userSelect = '';
  }
});

// Touch support for mobile divider
divider.addEventListener('touchstart', (e) => {
  isDragging = true;
  divider.classList.add('dragging');
  e.preventDefault();
});

document.addEventListener('touchmove', (e) => {
  if (!isDragging) return;
  const touch = e.touches[0];
  const rect = panels.getBoundingClientRect();
  const isMobile = window.innerWidth < 768;

  if (isMobile) {
    const fraction = (touch.clientY - rect.top) / rect.height;
    const clamped = Math.max(0.2, Math.min(0.8, fraction));
    panelEditor.style.flex = `0 0 ${clamped * 100}%`;
    panelOutput.style.flex = `0 0 ${(1 - clamped) * 100}%`;
  } else {
    const fraction = (touch.clientX - rect.left) / rect.width;
    const clamped = Math.max(0.2, Math.min(0.8, fraction));
    panelEditor.style.flex = `0 0 ${clamped * 100}%`;
    panelOutput.style.flex = `0 0 ${(1 - clamped) * 100}%`;
  }
});

document.addEventListener('touchend', () => {
  if (isDragging) {
    isDragging = false;
    divider.classList.remove('dragging');
  }
});

// ---------------------------------------------------------------
// Initialize compiler
// ---------------------------------------------------------------
async function init() {
  try {
    compiler = createWorkerCompiler({
      workerUrl: '/gh-aw/wasm/compiler-worker.js'
    });

    await compiler.ready;
    isReady = true;
    setStatus('ready', 'Ready');
    loadingOverlay.classList.add('hidden');

    // Compile the default content
    doCompile();
  } catch (err) {
    setStatus('error', 'Failed to load');
    loadingOverlay.querySelector('.f4').textContent = 'Failed to load compiler';
    loadingOverlay.querySelector('.f6').textContent = err.message;
    loadingOverlay.querySelector('.loading-spinner').style.display = 'none';
  }
}

init();
