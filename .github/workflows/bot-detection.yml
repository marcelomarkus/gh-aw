name: Bot Detection

on:
  workflow_dispatch:
  schedule:
    - cron: "0 * * * *"

permissions:
  contents: read
  pull-requests: read
  issues: write

jobs:
  detect-bots:
    runs-on: ubuntu-latest
    steps:
      - name: Detect brand new accounts with suspicious activity
        uses: actions/github-script@v7
        with:
          script: |
            const HOURS_BACK = 6;
            const MAX_PR = 50;
            const MIN_ACCOUNT_AGE_DAYS = 14;

            const cutoff = new Date(Date.now() - HOURS_BACK * 60 * 60 * 1000);

            const fs = require('fs');
            function appendSummary(markdown) {
              const summaryPath = process.env.GITHUB_STEP_SUMMARY;
              if (!summaryPath) return;
              fs.appendFileSync(summaryPath, `${markdown}\n`);
            }

            function buildAccountSummaryTable(sortedAccounts, limit) {
              const baseRepoURL = `https://github.com/${context.repo.owner}/${context.repo.repo}`;
              function linkCount(count, url) {
                if (!count) return '0';
                return `[${count}](${url})`;
              }

              const rows = [];
              const capped = sortedAccounts.slice(0, limit);
              for (const [login, data] of capped) {
                const encodedLogin = encodeURIComponent(login);
                const openIssues = (data.issues || []).filter(i => i.state === 'open').length;
                const closedIssues = (data.issues || []).filter(i => i.state === 'closed').length;
                const openPRs = (data.prs || []).filter(p => p.state === 'open').length;
                const closedPRs = (data.prs || []).filter(p => p.state === 'closed').length;
                const comments = (data.comments || []).length;

                const openIssuesLink = linkCount(openIssues, `${baseRepoURL}/issues?q=is%3Aissue+is%3Aopen+author%3A${encodedLogin}`);
                const closedIssuesLink = linkCount(closedIssues, `${baseRepoURL}/issues?q=is%3Aissue+is%3Aclosed+author%3A${encodedLogin}`);
                const openPRsLink = linkCount(openPRs, `${baseRepoURL}/pulls?q=is%3Apr+is%3Aopen+author%3A${encodedLogin}`);
                const closedPRsLink = linkCount(closedPRs, `${baseRepoURL}/pulls?q=is%3Apr+is%3Aclosed+author%3A${encodedLogin}`);
                const commentsLink = linkCount(comments, `${baseRepoURL}/issues?q=commenter%3A${encodedLogin}`);

                rows.push(`| @${login} | ${data.daysOld}d | ${openIssuesLink} | ${closedIssuesLink} | ${openPRsLink} | ${closedPRsLink} | ${commentsLink} |`);
              }

              const header = [
                '| Account | Age | Issues (open) | Issues (closed) | PRs (open) | PRs (closed) | Comments |',
                '| --- | ---: | ---: | ---: | ---: | ---: | ---: |',
              ];

              let table = header.concat(rows).join('\n');
              if (sortedAccounts.length > capped.length) {
                table += `\n\n_And ${sortedAccounts.length - capped.length} more account(s) not shown in summary._`;
              }
              return table;
            }

            // Fetch recent PRs (up to MAX_PR)
            const prs = [];
            if (github.paginate?.iterator) {
              for await (const response of github.paginate.iterator(github.rest.pulls.list, {
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'all',
                sort: 'updated',
                direction: 'desc',
                per_page: 100,
              })) {
                prs.push(...response.data);
                if (prs.length >= MAX_PR) break;
              }
            } else {
              const { data } = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'all',
                sort: 'updated',
                direction: 'desc',
                per_page: Math.min(100, MAX_PR),
              });
              prs.push(...data);
            }

            const highRiskAccounts = new Map();
            const commentsByUser = new Map();
            const userCreatedDates = new Map();
            const accountsSeen = new Set();
            let userLookupFailures = 0;

            async function ensureUserCreatedDate(login) {
              if (!login) return;
              accountsSeen.add(login);
              if (userCreatedDates.has(login)) return;
              try {
                const { data: userInfo } = await github.rest.users.getByUsername({ username: login });
                userCreatedDates.set(login, new Date(userInfo.created_at));
              } catch (e) {
                userLookupFailures += 1;
                userCreatedDates.set(login, null);
              }
            }

            for (const pr of prs.slice(0, MAX_PR)) {
              if (new Date(pr.updated_at) < cutoff) continue;

              await ensureUserCreatedDate(pr.user?.login);

              const issueComments = [];
              if (github.paginate?.iterator) {
                for await (const response of github.paginate.iterator(github.rest.issues.listComments, {
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: pr.number,
                  per_page: 100,
                })) {
                  issueComments.push(...response.data);
                }
              } else {
                const { data } = await github.rest.issues.listComments({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: pr.number,
                  per_page: 100,
                });
                issueComments.push(...data);
              }

              const reviewComments = [];
              if (github.paginate?.iterator) {
                for await (const response of github.paginate.iterator(github.rest.pulls.listReviewComments, {
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: pr.number,
                  per_page: 100,
                })) {
                  reviewComments.push(...response.data);
                }
              } else {
                const { data } = await github.rest.pulls.listReviewComments({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: pr.number,
                  per_page: 100,
                });
                reviewComments.push(...data);
              }

              // Review submissions (e.g., "LGTM" reviews) are NOT included in listReviewComments.
              const reviews = [];
              if (github.paginate?.iterator) {
                for await (const response of github.paginate.iterator(github.rest.pulls.listReviews, {
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: pr.number,
                  per_page: 100,
                })) {
                  reviews.push(...response.data);
                }
              } else {
                const { data } = await github.rest.pulls.listReviews({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: pr.number,
                  per_page: 100,
                });
                reviews.push(...data);
              }

              for (const comment of [...issueComments, ...reviewComments]) {
                if (new Date(comment.created_at) < cutoff) continue;
                const login = comment.user?.login;
                if (!login) continue;

                await ensureUserCreatedDate(login);

                if (!commentsByUser.has(login)) {
                  commentsByUser.set(login, []);
                }
                commentsByUser.get(login).push({
                  pr: pr.number,
                  url: comment.html_url,
                  timestamp: comment.created_at,
                });
              }

              for (const review of reviews) {
                const submittedAt = review.submitted_at || review.submittedAt;
                if (!submittedAt) continue;
                if (new Date(submittedAt) < cutoff) continue;

                const login = review.user?.login;
                if (!login) continue;

                await ensureUserCreatedDate(login);

                if (!commentsByUser.has(login)) {
                  commentsByUser.set(login, []);
                }

                const reviewURL = review.html_url || `${pr.html_url}#pullrequestreview-${review.id}`;
                commentsByUser.get(login).push({
                  pr: pr.number,
                  url: reviewURL,
                  timestamp: submittedAt,
                });
              }
            }

            // Also consider recent issue creators (not just PR comments).
            // This helps catch new accounts that only opened issues/PRs (even if already closed).
            try {
              const { data: recentIssues } = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'all',
                since: cutoff.toISOString(),
                per_page: 100,
              });

              for (const issue of recentIssues) {
                await ensureUserCreatedDate(issue.user?.login);
              }
            } catch (e) {
              // If issue listing fails, continue with PR/comment-based detection.
            }

            // Identify high-risk accounts
            const now = new Date();
            for (const [login, createdDate] of userCreatedDates) {
              if (!createdDate) continue;

              const daysOld = Math.floor((now - createdDate) / (24 * 60 * 60 * 1000));
              if (daysOld < MIN_ACCOUNT_AGE_DAYS) {
                highRiskAccounts.set(login, {
                  daysOld,
                  comments: commentsByUser.get(login) || [],
                  issues: [],
                  prs: [],
                });
              }
            }

            if (highRiskAccounts.size === 0) {
              let msg = `‚úÖ Bot Detection: no high-risk accounts (<${MIN_ACCOUNT_AGE_DAYS}d) detected in last ${HOURS_BACK}h.`;
              if (accountsSeen.size > 0) {
                msg += ` Checked ${accountsSeen.size} unique account(s).`;
              }
              if (userLookupFailures > 0) {
                msg += ` ‚ö†Ô∏è ${userLookupFailures} account lookup(s) failed.`;
              }
              appendSummary(msg);
              return;
            }

            // Fetch additional activity for high-risk accounts
            for (const [login, data] of highRiskAccounts) {

              try {
                const { data: issues } = await github.rest.issues.listForRepo({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  creator: login,
                  state: 'all',
                });
                data.issues = issues
                  .filter(i => !i.pull_request)
                  .filter(i => new Date(i.created_at) >= cutoff)
                  .map(i => ({
                    number: i.number,
                    title: i.title,
                    state: i.state,
                    created_at: i.created_at,
                    html_url: i.html_url,
                  }));
              } catch (e) {
                console.log(`Could not fetch issues for ${login}`);
              }

              try {
                const { data: prList } = await github.rest.pulls.list({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  state: 'all',
                  per_page: 100,
                });
                data.prs = prList
                  .filter(p => p.user?.login === login && new Date(p.created_at) >= cutoff)
                  .map(p => ({
                    number: p.number,
                    title: p.title,
                    state: p.state,
                    created_at: p.created_at,
                    html_url: p.html_url,
                  }));
              } catch (e) {
                console.log(`Could not fetch PRs for ${login}`);
              }
            }

            // Skip alerting if everything found is already closed.
            let hasAnyOpenItem = false;
            for (const [, data] of highRiskAccounts) {
              if (data.issues?.some(i => i.state === 'open')) {
                hasAnyOpenItem = true;
                break;
              }
              if (data.prs?.some(p => p.state === 'open')) {
                hasAnyOpenItem = true;
                break;
              }
            }

            if (!hasAnyOpenItem) {
              console.log('No open issues or PRs from new accounts; skipping alert issue.');

              const sorted = Array.from(highRiskAccounts.entries()).sort((a, b) => a[1].daysOld - b[1].daysOld);
              appendSummary(`‚ÑπÔ∏è Bot Detection: ${highRiskAccounts.size} new account(s) (<${MIN_ACCOUNT_AGE_DAYS}d) found in last ${HOURS_BACK}h, but all related issues/PRs are closed. No alert issue created.`);
              appendSummary('');
              appendSummary(buildAccountSummaryTable(sorted, 20));
              return;
            }

            // Build report
            const today = new Date().toISOString().split('T')[0];
            let body = `Recently-created accounts often indicate bots, spam accounts, or coordinated attacks.\n\n`;

            const sorted = Array.from(highRiskAccounts.entries()).sort((a, b) => a[1].daysOld - b[1].daysOld);

            for (const [login, data] of sorted) {
              body += `## @${login}\n`;
              body += `**Account age:** ${data.daysOld} day(s) old\n\n`;

              if (data.issues && data.issues.length > 0) {
                body += `### Issues Opened (${data.issues.length})\n`;
                for (const issue of data.issues) {
                  body += `- ${issue.html_url} (${issue.created_at})\n`;
                }
                body += `\n`;
              }

              if (data.prs && data.prs.length > 0) {
                body += `### Pull Requests Opened (${data.prs.length})\n`;
                for (const pr of data.prs) {
                  body += `- ${pr.html_url} (${pr.created_at})\n`;
                }
                body += `\n`;
              }

              if (data.comments && data.comments.length > 0) {
                body += `### Comments (${data.comments.length})\n`;
                for (const comment of data.comments.slice(0, 10)) {
                  body += `- ${comment.url} (${comment.timestamp})\n`;
                }
                if (data.comments.length > 10) {
                  body += `- ... and ${data.comments.length - 10} more comments\n`;
                }
                body += `\n`;
              }

              if (!data.issues?.length && !data.prs?.length && !data.comments?.length) {
                body += `*(No issues, PRs, or comments in the last ${HOURS_BACK} hours)*\n\n`;
              }
            }

            console.log('\nCreating security alert issue...');
              const title = `üö® HIGH RISK: Brand New Accounts ‚Äî ${today}`;
              let existingIssueNumber;

              try {
                const { data: existingIssues } = await github.rest.issues.listForRepo({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  state: 'open',
                  per_page: 100,
                });

                const existing = existingIssues.find(i => i.title === title);
                if (existing?.number) {
                  existingIssueNumber = existing.number;
                }
              } catch (e) {
                // If listing issues fails, fall back to creating a new issue.
              }

            try {
                if (existingIssueNumber) {
                  await github.rest.issues.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: existingIssueNumber,
                    body,
                  });
                  appendSummary(`üö® Bot Detection: updated alert issue #${existingIssueNumber} (found ${highRiskAccounts.size} new account(s) in last ${HOURS_BACK}h).`);
                } else {
                  await github.rest.issues.create({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    title,
                    body,
                    labels: ['security', 'bot-detection'],
                  });
                  appendSummary(`üö® Bot Detection: created alert issue (found ${highRiskAccounts.size} new account(s) in last ${HOURS_BACK}h).`);
                }
            } catch (e) {
                console.log('Issue create/update with labels failed; retrying without labels...');
                if (existingIssueNumber) {
                  await github.rest.issues.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: existingIssueNumber,
                    body,
                  });
                  appendSummary(`üö® Bot Detection: updated alert issue #${existingIssueNumber} (labels failed).`);
                } else {
                  await github.rest.issues.create({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    title,
                    body,
                  });
                  appendSummary('üö® Bot Detection: created alert issue (labels failed).');
                }
            }

            // Include a compact breakdown in the Step Summary for quick triage.
            appendSummary('');
            appendSummary(buildAccountSummaryTable(sorted, 20));
